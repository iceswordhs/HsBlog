services:
  # MySQL 服务
  mysql:
    image: iceswordhs/hs_blog_mysql:latest
    container_name: mysql
    restart: unless-stopped
    # 如果需要排查问题，可以打开注释 这样可以远程访问mysql
    # ports:
    #   - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_PASSWORD}
      MYSQL_DATABASE: hs_blog
    volumes:
      - ./mysql/data:/var/lib/mysql
      # - mysql_data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      timeout: 20s
      retries: 10

  # Redis 服务
  redis:
    image: redis:7-alpine
    container_name: redis
    restart: unless-stopped
    # 如果需要排查问题，可以打开注释 这样可以远程访问redis
    # command: redis-server --bind 0.0.0.0 --protected-mode no --requirepass "your password"
    command: redis-server  --requirepass '${REDIS_PASSWORD}'
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      timeout: 10s
      retries: 5

  # SpringBoot 后端服务
  backend:
    image: iceswordhs/hs_blog_backend:latest
    container_name: backend
    restart: unless-stopped
    environment:
      SPRING_PROFILES_ACTIVE: docker
      # 端口
      PORT: ${PORT}
      # 登陆token设置 token过期时间 86400000秒
      TOKEN_EXPIRE_TIME: ${TOKEN_EXPIRE_TIME}
      # token加密key
      BLOG_SECRET_KEY: ${BLOG_SECRET_KEY}
      # 博客名称
      BLOG_NAME: ${BLOG_NAME}
      CUSTOM_URL_CMS: ${CUSTOM_URL_CMS}
      CUSTOM_URL_WEBSITE: ${CUSTOM_URL_WEBSITE}

      #MySQL配置
      DB_URL: ${MYSQL_URL}
      DB_USERNAME: ${MYSQL_USER}
      DB_PASSWORD: ${MYSQL_PASSWORD}

      #邮件配置
      #你自己的邮箱地址
      MAIL_USERNAME: ${MAIL_USERNAME}
      #你自己的邮箱授权码
      MAIL_PASSWORD: ${MAIL_PASSWORD}
      #要发送到的邮箱
      EMAIL_TO_ACCOUNT: ${EMAIL_TO_ACCOUNT}

      REDIS_HOST: redis
      REDIS_PASSWORD: ${REDIS_PASSWORD}
      REDIS_PORT: ${REDIS_PORT}

      GITHUB_TOKEN: ${GITHUB_TOKEN}
      GITHUB_USERNAME: ${GITHUB_USERNAME}
      GITHUB_REPOS: ${GITHUB_REPOS}
    depends_on:
      mysql:
        condition: service_healthy
      redis:
        condition: service_healthy
    # healthcheck:
    #   test: ["CMD", "curl", "-f", "http://localhost:10000/actuator/health"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3

  # Nginx 服务 (优化重点)
  nginx:
    image: iceswordhs/hs_blog_frontend:latest
    container_name: nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      # ⚠️ 1. 挂载共享的证书 Volume 
      - ./nginx/ssl:/etc/letsencrypt:ro 
      # 2. 挂载 Nginx 配置文件 (使用一个支持 SSL 的配置)
      # - ./nginx/nginx-ssl.conf:/etc/nginx/nginx.conf:rw
      # 由于配置文件中使用了环境变量，无法直接挂载，需要使用模版文件让nginx先把环境变量替换成对应的值。之后nginx会自动根据生成的配置文件启动
      - ./nginx/nginx-ssl.conf.template:/etc/nginx/templates/nginx.conf.template
      # 移除原有的 /etc/nginx/conf.d/default.conf
      - /dev/null:/etc/nginx/conf.d/default.conf
      - ./nginx_logs:/var/log/nginx
    depends_on:
      - backend
    # 移除复杂的 command，让 Nginx 启动并读取配置即可
    command: "nginx -g 'daemon off;'"

  # # Certbot 临时服务定义 (用于 Cron Job)
  # certbot:
  #   image: iceswordhs/certbot:latest
  #   # 不需启动
  #   command: "true"
  #   volumes:
  #     # 1. 证书 Volume (与 Nginx 共享)
  #     - certbot_certs:/etc/letsencrypt
  #     # 2. 挂载 DNSPod 凭证文件
  #     - ./dnspod.ini:/dnspod.ini:ro 
  #     # 3. 存储 Certbot 工作和日志数据
  #     - certbot_work:/var/lib/letsencrypt

volumes:
  redis_data:
  # certbot_certs: # 存储证书
  # certbot_work: # 存储 Certbot 工作数据



#   # Nginx 服务
#   nginx:
#     image: iceswordhs/hs_blog_frontend:latest
#     container_name: nginx
#     restart: unless-stopped
#     ports:
#       - "80:80"
#       - "443:443"
#     volumes:
#       # 挂载 SSL 证书目录 (只读)
#       - ssl_certificates:/etc/letsencrypt:ro
#       # Certbot Webroot 路径 (读写)
#       - ssl_webroot:/var/www/certbot:rw
#       # 挂载 SSL 配置文件 (只读)
#       - ./nginx/nginx-ssl.conf:/etc/nginx/nginx-ssl.conf:ro
#       # 挂载 HTTP 配置文件 (只读，初始配置)
#       - ./nginx/nginx-http.conf:/etc/nginx/nginx.conf:ro
#     depends_on:
#       - backend
#       # - certbot  # 在启动阶段，Nginx 可能不依赖 Certbot (Certbot 依赖 Nginx 启动)
#     command: >
#       sh -c "
#       nginx &

#       until [ -f /etc/letsencrypt/live/$${DOMAIN}/fullchain.pem ] && [ -f /etc/letsencrypt/live/$${ADMIN_DOMAIN}/fullchain.pem ]; do
#       echo '等待证书生成...'; sleep 5;
#       done;

#       echo '证书已生成，切换为HTTPS配置';
#       cp /etc/nginx/nginx-ssl.conf /etc/nginx/nginx.conf;
#       nginx -s quit;
#       nginx -g 'daemon off;'
#       "

#   # Certbot SSL证书服务 - 申请两个证书
#   certbot:
#     image: certbot/certbot
#     container_name: certbot
#     volumes:
#       - ssl_certificates:/etc/letsencrypt:rw
#       - ssl_webroot:/var/www/certbot:rw
#     environment:
#       - DOMAIN=${DOMAIN}
#       - ADMIN_DOMAIN=${ADMIN_DOMAIN}
#       - EMAIL=${EMAIL}
#     entrypoint: /bin/sh
#     depends_on:
#       - nginx
#     command:
#       - -c
#       - |
#         echo "等待 nginx-temp 启动..." && sleep 5 &&
#         certbot certonly --staging --webroot --webroot-path /var/www/certbot \
#         --email "$EMAIL" --agree-tos --no-eff-email \
#         -d "$DOMAIN" -d "www.$DOMAIN" --non-interactive && \
#         certbot certonly --staging --webroot --webroot-path /var/www/certbot \
#         --email "$EMAIL" --agree-tos --no-eff-email \
#         -d "$ADMIN_DOMAIN" --non-interactive && \
#         echo "所有SSL证书申请完成" && \
#         tail -f /dev/null

# volumes:
#   # mysql_data:  # 被注释掉，保留您提供的结构
#   redis_data:
#   ssl_certificates:
#   ssl_webroot: